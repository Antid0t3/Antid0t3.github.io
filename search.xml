<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IDA爆破账号密码]]></title>
    <url>%2F2019%2F11%2F28%2FIDA%E7%88%86%E7%A0%B4%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本文主要记录用IDA爆破账号密码。 本文是接着上一篇爆破签名验证的工作进一步深入，尝试爆破一下账号和密码。前面的处理代码的步骤完全一致，我们不再接着赘述，我们接着尝试爆破一下他的账号和密码。apk链接：https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g 密码：duv5 我们查看汇编界面的图形界面，我们发现上次是修改一个判断绕过签名验证，同理我们是否能修改下面代码中的判断语句来随便输入账号和密码就能登录成功呢？ 我们看到上图中两个判断语句，我们先修改第一个，将BNE改为BEQ。 再修改第二个判断的语句，将BEQ改为BNE。 保存so文件，然后替换掉原先armeabi和armeabi-v7a里面的so文件。 然后重新打包，签名安装。 总结一下：首先要找到java所调用的native层的方法，再通过汇编代码、c理解代码逻辑，当中可以使用汇编的图形界面，可以快速帮助我们理解代码结构。往往需要修改的地方都是一些判断的语句，注意一下这些地方，可以很快的帮助到我们。特别感谢吾爱破解论坛，我也是跟着论坛中的教学一步一步学习的，希望可以一步一个脚印把知识学扎实。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDA爆破签名验证]]></title>
    <url>%2F2019%2F11%2F28%2FIDA%E7%88%86%E7%A0%B4%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[本文主要记录用IDA爆破签名验证。 爆破的Demo是一款黑宝宝apk，他设置了签名验证，如果你反编译后重新打包签名，他会将该签名与原签名就行对比，你安装在手机上之后一打开程序则会退出。看一下代码发现签名验证是写在so里面的。接下来爆破他的签名验证。apk链接：https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g 密码：duv5 用apktool解包apk,然后用IDA打开libJniTest.so。 文件中有Imports表和Exports表Imports是导入表，so中调用的外面的函数。Exports是导入表，so中能让外部调用的函数。我们在java层可以知道调用了一个native层的函数check，然后Exports表记录了so中被外部调用的函数，而且我们清楚so中的函数都是以java_包名_类名_方法名的格式所命名。那么我们直接在Exports表中搜索check,就可以搜到该函数。 我们找到check函数后双击它进入check方法。 我们按F5将汇编语言变为c语言。 我们发现存在一些乱码，我们按alt+a键，将如图所示编码改为UTF-8。点击ok后，再重新刷新之后就可以发现乱码没有了。 乱码问题虽然解决了 但是下面的代码可读性很差 此时需要导入jni.h文件,点File-&gt;Load file-&gt;Parse C header file,找到jni.h所在位置点击打开,此时显示Compilation successful导入成功。下载链接：https://pan.baidu.com/s/1n16NEx67zLHfGtVpU-CKAA 密码：7xg6 我选中第一个int,右键选择Convert to struct*，选择_JNIEnv,点击ok,我们发现有一些函数已经显示出来了。 但是函数的可读性还是差了一些，我们选中函数GetStringUTFChars,右键选择force call type，其他的函数也同样这样，之后我们发现代码的可读性提高了。 我们点选中a1,然后按n键重命名为env，至于为什么这样做，不是这节课的重点，以后的博客中会讲到。 现在我们回到汇编视图，按空格键就可以切换到图形视图。图形视图我们可以一目了然的看清代码结构，我们也可以按住ctrl滑鼠标的滑轮来调节视图的大小。 我们可以看到判断签名的代码。调用strcmp函数来比较现在的签名和原来的签名是否一致，如一致R0标志位置为0，比较标志位置是否为0，为0程序走左视图，不为0走右视图。 我们想要让他通过，很显然，我们把BNE(不等于0)修改为BEQ(等于0)，这样我们修改完签名后，程序就会走左视图，就不会因为签名验证不能正常运行程序。我们鼠标选中BNE，然后按空格键切换回汇编视图，选中BNE,然后点击View-&gt;open subview-&gt;hex dump。 然后我们可以看到BNE对应的16进制，我们只需要将BNE的16进制改为BEQ的16进行就成功了。BNE是D1,BEQ是D0，我们修改后保存就修改成功。 返回到汇编视图也可以看到修改成功。 我们保存修改后的so文件。我们将修改后的so文件替换掉原先armeabi和armeabi-v7a里面的so文件。 重新打包，签名，安装到手机就可以正常的运行了。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的几种编码方式]]></title>
    <url>%2F2019%2F11%2F28%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文记录了字符常见的几种编码方式 无论在是在编辑文本文件的时候，还是在制作网页的时候，总会遇到文本编码方式的问题。如果处理不当，就会出现乱码的问题。因此，有必要对文本的编码方式做一个详尽的了解。常见的一些字符编码方式无非有：Unicode、ASCII、GBK、GB2312、UTF-8。下面先对常见的这一些字符编码方式作下说明： 1.ASCII码这是美国在19世纪60年代的时候为了建立英文字符和二进制的关系时制定的编码规范，它能表示128个字符，其中包括英文字符、阿拉伯数字、西文字符以及32个控制字符。它用一个字节来表示具体的字符，但它只用后7位来表示字符（2^7=128），最前面的一位统一规定为0。 2.扩展的ASCII码原本的ASCII码对于英文语言的国家是够用了，但是欧洲国家的一些语言会有拼音，这时7个字节就不够用了。因此一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使 用的编码体系，可以表示最多256个符号。但这时问题也出现了：不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码 中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。这个问题就直接促使了Unicode编码的产生。 3.Unicode符号集正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。而Unicode就是这样一种编码：它包含了世界上所有的符号，并且每一个符号都是独一无二的。比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表 。很多人都说Unicode编码，但其实Unicode是一个符号集（世界上所有符号的符号集），而不是一种新的编码方式。但是正因为Unicode包含了所有的字符，而有些国家的字符用一个字节便可以表示，而有些国家的字符要用多个字节才能表示出来。即产生了两个问题：第一，如果有两个字节的数据，那计算机怎么知道这两个字节是表示一个汉字呢？还是表示两个英文字母呢？第二，因为不同字符需要的存储长度不一样，那么如果Unicode规定用2个字节存储字符，那么英文字符存储时前面1个字节都是0，这就大大浪费了存储空间。上面两个问题造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode在很长一段时间内无法推广，直到互联网的出现。 4.UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8的编码规则很简单，只有两条：1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 5.GBK/GB2312/GB18030GBK和GB2312都是针对简体字的编码，只是GB2312只支持六千多个汉字的编码，而GBK支持1万多个汉字编码。而GB18030是用于繁体字的编码。汉字存储时都使用两个字节来储存。 总的来说：ASCII编码：用来表示英文，它使用1个字节表示，其中第一位规定为0，其他7位存储数据，一共可以表示128个字符。拓展ASCII编码：用于表示更多的欧洲文字，用8个位存储数据，一共可以表示256个字符GBK/GB2312/GB18030：表示汉字。GBK/GB2312表示简体中文，GB18030表示繁体中文。Unicode编码：包含世界上所有的字符，是一个字符集。UTF-8：是Unicode字符的实现方式之一，它使用1-4个字符表示一个符号，根据不同的符号而变化字节长度。 详细链接：http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.htmlhttps://blog.csdn.net/byf0521hlyp/article/details/80365045]]></content>
      <categories>
        <category>计算机技术</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDA破解第一个so]]></title>
    <url>%2F2019%2F11%2F27%2FIDA%E7%A0%B4%E8%A7%A3%E7%AC%AC%E4%B8%80%E4%B8%AAso%2F</url>
    <content type="text"><![CDATA[本文主要记录用IDA破解第一个so 首先下载工具IDA。链接：https://pan.baidu.com/s/15uCX8o6tTSSelgG_RN7kBQ密码：ftie 本文所用到的Demo是上个博客所生成的so文件。链接：https://pan.baidu.com/s/1vKC1SevvHfeI7f0d2c6IqQ密码：u1an 我们首先使用apktool反编译，得到了反编译后的文件夹app-debug 然后我们打开文件夹找到lib文件，可以看到里面有基于不同cpu的so文件。因为我的机型是支持arm的所以我这里打开的是armeabi文件夹下的so，如果机型是x86模式的那么这里要打开x86模式下的libJniTest.soarmeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的大部分Android设备都使用它.arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。x86: 平板、模拟器用得比较多。x86_64: 64位的平板。 我们现在打开下载好的的IDA，遇到的弹窗全部选择ok。我们用IDA打开so文件。 我们按住shift+f12打开字符串窗口 这个窗口将会列举出so中所包含的所有字符串 我们只编写了一个字符串 所以这里只有一个hello byx! 如果打开的是x86的so这里还会有一些.so 但是字符串只有这一个。 我们双击字符串点进去如图所示，我们可以看到字符串对应的内存地址00001DF8。 我们把鼠标放在hello byx上，点击工具栏里面的View-&gt;opensubview-&gt;hex dump 然后我们可以看到对应内存地址上的内容。关于字符对应的16进制可以搜索ascii表，找到字符对应的16进制。 我们尝试把hello byx 改为hello pzb。我们利用在线ascii转换工具分别转换这两个字符串。 我们在IDA中右键选择编辑。将62 79 78改为 70 7a 62 然后我们再右键选择apply changes 我们选择edit-&gt;plugins-&gt;modifyfile来保存修改后的so。 我们确定修改并将修改后的so单独的放在一个位置。 我们将IDA关闭，然后将修改后的so替换armeabi文件夹和armeabi-v7a文件下的so文件。然后我们重新打包app-debug。然后打开AndroidKiller为打包好的apk进行签名。 然后我们使用adb install D:\apk\破解so\test_sign.apk安装apk 我们打开AndroidStudio查看打印的log。成功修改！]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apktool的使用]]></title>
    <url>%2F2019%2F11%2F27%2Fapktool%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文主要介绍一下apktool的使用 一、下载最新版apktool,官网链接:https://ibotpeaches.github.io/Apktool/ 二、配置apktool1.将下载好的apktool重命名为apktool.jar 并下载apktool.bat 下载链接：https://pan.baidu.com/s/1ClEDZ1yiUobG46sQtaSY8Q 密码：gofa2.将下载的apktool重命名为apktoool.jar 并把apktool.bat一起放到C:\Windows目录下 按住快捷键win+R,输入cmd快捷键打开cmd命令窗口,输入apktool,配置成功显示如下: apktool 常用的两个命令如下解包：apktool d test.apk重新打包：apktool b test -o testc.apk 解压的text文件夹是解包后的文件夹 在这里我们可以修改apk里面的一些文件 那么testc.apk就是重打包后的apk以下以上一篇博客AndroidStudio编写第一个so编写出的app-debug.apk测试为例子 1.cd 进入apk所在目录 输入解包命令解包成功会在当前目录下生成app-debug文件夹apktool d app-debug.apk 2.输入重打包命令 -o是重命名apktool b app-debug -o testc.apk 打开命令窗口输入adb install apk文件 发现安装失败提示了Failure [INSTALL_FAILED_TEST_ONLY]这个错误 这个错误有两个解决办法：第一种：在安装命令中加入-t.即adb install -t D:\AndroidStudioProjects\TestJni2\app\build\outputs\apk\debug\testc.apk 第二种：修改AndroidManifest.xml文件，把android:testOnly=”true”改成android:testOnly=”false”或者删掉这一行。 我们就用第一种方法安装，发现安装又出现了错误：Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES]它提示没有签名。我们打开AndroidKiller-工具-apk签名，把需要签名的testc.apk拖进去，进行签名 签名完成后，在testc.apk同目录的文件夹下生成一个签名后的apk文件 签名后我们再进行apk的安装，这次就顺利安装成功！]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio编写第一个so]]></title>
    <url>%2F2019%2F11%2F26%2FAS%E7%BC%96%E5%86%99%E7%AD%89%E4%B8%80%E4%B8%AAso%2F</url>
    <content type="text"><![CDATA[本文主要记录用AndroidStudio编写第一个so 打开AndroidStudio新建一个Android项目，在包里面建一个普通的java类，里面写上如图所示的代码。里面有一个sayhello的方法和一个加载so库的静态初始化块。静态初始化块中的JniTest是我们提前给so库名。我们发现方法标红，是因为没有生成对应的头文件和so库，我们下一步就会完成这些 我们使用命令行在java目录下执行javah -d ../jni 包名.类名，会在java上一级目录中生成一个jni文件夹（该文件夹与java同级）,文件夹中存放的就是.h的头文件。 接着在jni文件夹中创建一个main.c文件，把.h的头文件导入进去，把sayhello方法在main.c中实现。 把下载的ndk环境与AndroidStudio关联起来，local.properties也会显示出ndk的路径。 打开app Module的build.gradle文件，在defaultConfig节点里添加以下代码 注意这里的moduleName，是我们在之前自己编写的类里面加载的so库名。 ndk { moduleName &quot;JniTest&quot; ldLibs &quot;log&quot;, &quot;z&quot;, &quot;m&quot; abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot; } 还要在gradle.properties里面加上这么一句话：android.useDeprecatedNdk=true 接下来直接rubuild project 发现出现了错误，修改gradle.properties里面这一句话：android.useDeprecatedNdk=true，按照如图所示修改，就成功了 可能出现这种错误，在jni文件夹下建一个.c的空文件夹就可以解决。（该错误时不时的会出现，具体原因以后再把它搞清楚） 我们rebuild一下就可以生成so库了 生成的so在项目的app\build\intermediates\ndk\debug\lib路径下 我们可以在main目录下建立一个jniLIB,然后把lib里面的文件复制过来。 so库生成完毕，现在我们在Mainactivity中打印MyJBI中的sayhello()。成功实现！]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Smali代码中插入Log]]></title>
    <url>%2F2019%2F11%2F24%2FSmali%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%8F%92%E5%85%A5Log%2F</url>
    <content type="text"><![CDATA[本文主要介绍在Smali代码中插入Log。 这里我编写了一个Demo 从下面的代码中可以看出我在onCreate方法中执行了三个函数 函数名分别是fun1 fun2和fun3 并且在下面加入一条Log 目的是为了打印出函数fun1的返回值 因为Log.i的两个参数都必须是String类型 所以这里把int类型的fun1这个函数通过String.valueOf函数转换成String类型 public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); fun1(); fun2(); fun3(); Log.i(&quot;这个值是&quot;,String.valueOf(fun1())); } public int fun1() { int value = Test.value; return value; } public int fun2() { int value2 = Test.value2; return value2; } public String fun3() { String str = Test.str; String str2 = Test.str2; int value3 = Test.value3; return str2; } } 接下来我们需要完成以下三个任务：任务一添加Log打印出fun2,fun3的值 (其实就是函数的返回值)任务二添加Log打印出fun3里面String类型str的值任务三添加Log打印出fun3里面int类型value3的值 首先我们来完成任务一。我们先来打印fun2的值，我们发现原来已经打印过fun1的值了，fun2和fun1函数返回值类型都一样，都需要调用String.valueOf()来转化为int类型，那我们打印fun2就很简单了，只需要找到fun1的打印语句的代码，换成fun2就成功了。 我们现在来打印fun3的值，我们发现fun3的返回值直接就是String类型的，我们只需要将上面fun1和fun2的代码中的fun1改为fun3，并将返回值类型改为String，并且将类型转换的代码删掉就成功了。任务一就成功完成了 现在来完成第二个任务，打印fun3中String类型的str的值。我们直接找到fun3方法中的str值，他一定会将str的值放到一个寄存器中，我们找到这个寄存器，然后打印出他的值就成功了，顺利完成任务二。 现在我们来完成任务三，我们思路跟任务二相同，在fun3方法中找到存放value3的寄存器，然后尝试把他打印出来。 本节课从简单的插入Log到从smali代码中打印变量的值,然后从中牵扯到了类型转换,最后通过完成三条任务为主线,每一个例子 每一个点都很精致并且实用,这节课的内容可以留着当做Log方面参考文档 虽然本节课的篇幅比较长 但是所讲的所有东西,最好自己能有一些心得。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态调试Smali代码]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95Smali%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本文主要介绍一下利用Android Studio动态调试Smali代码 第一步：我们使用上一次自己编写的一个简单的登录界面的apk，我们先把这个apk扔到AndroidKiller里面，反编译这个apk。 我们通过AndroidManifest.xml文件找到程序的包名和入口 我们查看AndroidManifest.xml是否存在android:debuggable=”true”这句代码，没有是不能调试apk的 现在调试的这个例子默认是有这句代码的 有的apk中没有这句代码要自行添加上有是不能调试apk的。 第二步：然后我们使用命令adb install apk文件 将apk安装到手机中，打开usb调试模式。 第三步：然后我们打开Smali文件所在的位置，把Smali代码复制到新建的D盘下的一个单独的jwx02文件夹中，并改名为src。 第四步：在AndroidStudio设置中需要安装好Smalidea插件，如果是已经默认安装好的就不用再安装了。 第五步：导入jwx02这个文件到AndroidStudio中。点击File之后选择import project，然后把刚才单独创建的jwx02文件夹导入进来。 第六步：然后将src目录设置为sources root,这一步告诉AndroidStudio这个文件夹下的是源代码。 第七步：接下来配置远程调试选项。选择Run–&gt;Edit Configurations 并增加一个Remote调试的调试选项，端口选择:8700。 第八步：配置JDK。选择File–&gt;Project Structure 配置JDK 第九步：打开Android Device Monitor 第十步：打开cmd,输入命令adb shell am start -D -n hfdcxy.com.myapplication/hfdcxy.com.myapplication.MainActivity 对apk进行动态调试 这条命令运行后手机屏幕将会进入到调试界面(如果手机屏幕没有进入到调试界面说明USB没有连接好手机 或者USB调试模式 没有打开 或者其他原因) 第十一步：打开AndroidStudio,对希望查看的关键代码下断点，之后点击Run,选择debug smali，这里smali是我们之前配置好的调试选项。此时手机会进入程序 在手机上输入用户名和密码 点登陆 程序会断在我下的断点处。F8执行下一步，F9运行程序。 其中第一、二步是查看反编译后的代码，并将apk安装到手机中。第三步到第八步是将反编译后的smali代码导入到AndroidStudio中，并且配置好相关的环境（sources root、Remote、JDK）第九步到第十一步是使用命令对手机开始进行动态调试。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切水果大战]]></title>
    <url>%2F2019%2F11%2F18%2F%E5%88%87%E6%B0%B4%E6%9E%9C%E5%A4%A7%E6%88%98%2F</url>
    <content type="text"><![CDATA[本文主要记录破解切水果大战游戏的思路。 拿到这一款切水果游戏，首先安装到手机上玩一下。命令：adb install apk文件体验之后发现一般的道具消费都会提示充值金币，没有充值的话会提示失败我们尝试破解 将APK文件拖到Android Killer 进行反编译，我们看到反编译后的文件我们尝试进行关键字搜索“失败”我们会发现关于支付的代码。 我们浏览代码，可以看java代码，如果对smali代码熟练的话直接看smali 代码，我发现了支付失败的方法、支付成功的方法、支付取消的方法。 接下来我们尝试用三种方法进行破解第一种方法：我们找到了代码中支付失败、支付取消和支付成功的代码，我们可以直接将支付失败和支付取消的方法中的代码全部改为支付成功的代码。第二种方法：第一种方法是直接改支付失败里面的代码，将他们改成支付成功，这是一种思路，我们现在尝试第二种方法，尝试看一下支付失败的代码是在哪里被调用的。我们尝试搜索payResultFalse()方法，搜索到调用payResultFalse()的文件，如图所示，我们发现了调用支付失败和支付成功的位置，我们把调用支付失败的方法改成调用支付成功的方法。破解成功。第三种方法，我们修改switch分支，把:pswitch_1修改为:pswitch_0，这样代码只会跳转到支付成功的方法处，破解成功。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[火柴人联盟]]></title>
    <url>%2F2019%2F11%2F18%2F%E7%81%AB%E6%9F%B4%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[本文主要记录破解火柴人联盟游戏的思路。 安装火柴人游戏玩一下，发现游戏里面有商城，商城里面提供了需要购买的道具，还有一些礼包也需要购买，英雄也需要购买，支付方式分为了话费支付、三方支付。 我们尝试一下搜索一下关键的字符：支付失败、支付成功我们在查询过程中就可以看到支付信息代码所在的文件目录，我们一一打开，发现有短信、联通、移动、电信几种支付方式 我们可以看到关于支付信息的代码 我们先打开联通的支付，smali代码如下，就是一个简单的switch语句，我们将支付取消和支付失败的switch语句调用全部改为支付成功的情况。 我们在点击电信的支付信息，可以看到电信相关的支付成功的方法、支付失败的方法、支付取消的方法。我们使用最简单的方法，将支付失败和支付取消里面的代码全部改为支付成功的代码 我们在看一下移动支付的代码，和联通的基本一样，也是switch语句，我们还是果断使用switch大法，成功解决。 最后还有一部分去广告，同意支付接口的一系列操作后面再补充。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名网络Tor与I2P的比较研究]]></title>
    <url>%2F2019%2F11%2F08%2F%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9CTor%E4%B8%8EI2P%E7%9A%84%E6%AF%94%E8%BE%83%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[本文主要记录匿名网络Tor与I2P的主要区别。 Tor（the onion router）是部署最多的匿名通信系统，提供在线匿名和隐私保护，而隐形互联网I2P（invisible Internet project）允许应用程序通过使用大蒜路由，以匿名和安全方式相互发送消息。 Tor与I2P使用术语与一些关键区别： Tor匿名网络 I2P匿名网络 基于电路的低延迟覆盖网络 基于分组的高延迟重叠网络 允许匿名访问分别实施和操作外部互联网服务 试图将现有的互联网服务转移到I2P网络，并在框架内提供服务实现 双向电路 单向通道 集中式框架 分布式架构 使用Socket Secure（SOCKS）接口，只能通过TCP传输消息 I2P 是一个中间件，提供应用程序可用于通过网络进行通信的API，可以在UDP和TC之间进行选择 Cell，细胞 Message，消息 Client，客户 Router、Clients，路由器或客户端 Circuit，电路 Tunnel，隧道 Directory，目录 Net DB，网络数据库 directory server，目录服务器 floodfill router，floodfill 路由器 Entry guard，入境卫兵 Fast peer，快速对等体 Ingress node，入口节点 Inproxy，入口代理 exit node，退出节点 Outproxy，出口代理 hidden service，隐藏服务 Eepsite or destination，Eepsite 或目的地 hidden service descriptor，隐藏服务描述符 lease set，租约集 introduction point，介绍点 inbound gateway，入站网关 onion routing，洋葱路由 garlic routing，大蒜路由 Node、Server，节点、服务器 Router，路由器 Onion agent，洋葱代理 I2P Tunnel 客户端 Onion service，洋葱服务 隐藏服务，Eepsite 或目的地 Rendezvous Point，会合点 Inbound Gateway+Outbound Endpoint，入站/出站网关 Router descriptor，路由器描述符 Routerinfo，路由器信息 Tor和I2P开发技术比较： 特征 域名 节点选择标准 目录服务器/floodfill 对等体 分组/电路交换 单向/双向 保护以免检测客户端活动 隧道/电路的期限 TCP/UDP传输 SOCKS/ I2P API Tor .onion 信任、声明、能力 信任和硬编码 电路交换 双向电路 较少保护 时间长 TCP SOCKS I2P .i2p 不断分析和排名性能 多变且不可信 分组交换 单向隧道 较多保护 时间短 两者都可以 I2P API]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>匿名网络</tag>
        <tag>流量识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登山赛车破解]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%99%BB%E5%B1%B1%E8%B5%9B%E8%BD%A6%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文主要记录破解登山赛车游戏的思路。 下载好apk ,放入模拟器中试玩一下，我们点击购买金币，不支付的话会提示购买失败。 我们可以看到付款失败特别明显，我们可以把apk拖进android killer里面搜索一下付款 失败的字符，找到提示付款失败的代码。 可以看到是一个switch语句，我们找到添加金币的代码。 这里是付款失败的代码块 下面两端代码块是添加的金币的代码块。 我们尝试把它拖到最下面，可以看到这样的代码。 我们将两个都改为:pswitch_0。 编译完成，再拖入模拟器里面试一下 成功获取金币，破解成功。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解糖果星星达人]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%A0%B4%E8%A7%A3%E7%B3%96%E6%9E%9C%E6%98%9F%E6%98%9F%E8%BE%BE%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[本文主要记录破解糖果星星达人游戏思路。 试玩一下糖果星星达人，尝试一下破解金币。把apk 扔到模拟器里面玩一下，还是蛮好玩的，反正死了就要让你充值金币，我们任意输入他提示购买失败，我们尝试一下破解。试着将apk扔进Android Killer里面，搜过一下关键字“购买失败” 很简单，就是个switch语句，上下浏览一下，找到购买成功 我们还看到了购买取消，我们拖到最下面，尝试把5、6改成4，看能否成功 重新编译，放入模拟器中，购买成功。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
</search>
