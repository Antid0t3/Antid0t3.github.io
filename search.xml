<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[x86汇编-实验7]]></title>
    <url>%2F2020%2F01%2F09%2Fx86%E6%B1%87%E7%BC%96-%E5%AE%9E%E9%AA%8C7%2F</url>
    <content type="text"><![CDATA[本文主要记录使用x86汇编进行编程，完成实验七 本次实验来源于王爽的《汇编语言》实验七 我们一共完成了三个版本，逐渐精简、优化。第一个版本将表格的每一列使用一个循环进行写入，分别是年份、总收入、人数、人均收入每一个循环循环21次，其中年份、总收入每一次循环写入4个字节，人数、人均收入每次写入2个字节年份是字节型数据，可以一个一个字节的写入，总收入是双字型数据（32位），需要用dx存储高16位，ax存储低16位数据。索引方式可以使用idata[si]或者[dx].idata[si]的方式。人数和人均收入是字型数据，利用通用寄存器就可以了。第一版如图所示 assume cs:code,ds:data,es:table data segment ;0-53h db &apos;1975&apos;,&apos;1976&apos;,&apos;1977&apos;,&apos;1978&apos;,&apos;1979&apos;,&apos;1980&apos;,&apos;1981&apos;,&apos;1982&apos;,&apos;1983&apos; db &apos;1984&apos;,&apos;1985&apos;,&apos;1986&apos;,&apos;1987&apos;,&apos;1988&apos;,&apos;1989&apos;,&apos;1990&apos;,&apos;1991&apos;,&apos;1992&apos; db &apos;1993&apos;,&apos;1994&apos;,&apos;1995&apos; ;54h-A7h dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;A8h-D1h dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 data ends table segment db 21 dup(&apos;year sumn ne ?? &apos;) table ends code segment start: mov ax, data mov ds, ax mov ax, table mov es, ax mov bx, 0 mov di, 0 mov si, 0 mov cx, 21 s0: mov al, [bx] mov es:[di], al mov al, [bx+1] mov es:[di+1], al mov al, [bx+2] mov es:[di+2], al mov al, [bx+3] mov es:[di+3], al add bx, 4 add di, 16 loop s0 ;mov bx，54h mov di, 0 mov si, 0 mov bx, 0 mov dx, 0 mov cx, 21 s1: mov ax, 54h[bx] mov dx, 56h[bx] mov es:5h[di], ax mov es:7h[di], dx add bx, 4 add di, 16 loop s1 ;mov bx, 0A8h mov di, 0 mov si, 0 mov bx, 0 mov cx, 21 s2: mov ax, 0A8h[bx] mov es:[di+0Ah], ax add bx, 2 add di, 16 loop s2 mov di, 0 mov si, 0 mov dx, 0 mov cx, 21 s3: mov dx, es:[di+7] mov ax, es:[di+5] div word ptr es:[di+0Ah];除以内存，必须指定大小 mov es:[di+0Dh],ax add di, 16 loop s3 mov ax, 4c00h int 21h code ends end start 第二版将四个循环合并成为了一个循环，大大精简了程序，提高了效率。其中主要是多利用了si寄存器，因为年份、总收入一次循环需要增加4个字节，而人数、人均收入一次循环只需要增加2个字节，所以我们使用bx表示年份和总收入的偏移，si寄存器来表示人数的偏移，这样我们就可以在一个循环里完成所有的工作。 assume cs:code,ds:data,es:table data segment ;0-53h db &apos;1975&apos;,&apos;1976&apos;,&apos;1977&apos;,&apos;1978&apos;,&apos;1979&apos;,&apos;1980&apos;,&apos;1981&apos;,&apos;1982&apos;,&apos;1983&apos; db &apos;1984&apos;,&apos;1985&apos;,&apos;1986&apos;,&apos;1987&apos;,&apos;1988&apos;,&apos;1989&apos;,&apos;1990&apos;,&apos;1991&apos;,&apos;1992&apos; db &apos;1993&apos;,&apos;1994&apos;,&apos;1995&apos; ;54h-A7h dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;A8h-D1h dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 data ends table segment db 21 dup(&apos;year sumn ne ?? &apos;) table ends code segment start: mov ax, data mov ds, ax mov ax, table mov es, ax mov bx, 0 mov di, 0 mov si, 0 mov cx, 21 s0: mov al, [bx] mov es:[di], al mov al, [bx+1] mov es:[di+1], al mov al, [bx+2] mov es:[di+2], al mov al, [bx+3] mov es:[di+3], al ;以上是复制年份 mov ax, 54h[bx] mov dx, 56h[bx] mov es:5h[di], ax mov es:7h[di], dx ;以上是复制总收入 mov ax, 0A8h[si] mov es:[di+0Ah], ax ;以上是复制人数 mov dx, es:[di+7] mov ax, es:[di+5] div word ptr es:[di+0Ah];除以内存，必须指定大小 mov es:[di+0Dh],ax ;以上是计算人均收入 add si, 2 add bx, 4 add di, 16 loop s0 mov ax, 4c00h int 21h code ends end start 第三版更为精简，由于年份每次循环要写入4个字节，用上面的办法显得很冗长，我们直接使用一个循环就可以顺利解决，使得程序更加简洁。需要注意几个要点：1、我要需要临时保存cx、bx的值，需要引入栈，我们需要设置好栈的相关信息。例如：需要保存寄存器cx值的时候使用push cx将值入栈，重新给寄存器cx赋值使用，当需要使用原先的值的时候，使用pop cx将值出栈赋值给cx。使用过程中注意栈的原理FILO(先进后出)。2、寄存器di、si 不能够同时使用，我们将si作为表一即源数据的偏移地址，使用di表示表二即目标数据的偏移地址，使用dx来辅助表示偏移地址。 assume cs:code,ds:data,es:table,ss:stack data segment ;0-53h db &apos;1975&apos;,&apos;1976&apos;,&apos;1977&apos;,&apos;1978&apos;,&apos;1979&apos;,&apos;1980&apos;,&apos;1981&apos;,&apos;1982&apos;,&apos;1983&apos; db &apos;1984&apos;,&apos;1985&apos;,&apos;1986&apos;,&apos;1987&apos;,&apos;1988&apos;,&apos;1989&apos;,&apos;1990&apos;,&apos;1991&apos;,&apos;1992&apos; db &apos;1993&apos;,&apos;1994&apos;,&apos;1995&apos; ;54h-A7h dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;A8h-D1h dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 data ends table segment db 21 dup(&apos;year sumn ne ?? &apos;) table ends stack segment dw 0,0 stack ends code segment start: mov ax, data mov ds, ax mov ax, table mov es, ax mov ax, stack mov ss, ax mov sp, 4 mov bx, 0 mov di, 0 mov si, 0 mov cx, 21 s0: push cx push bx mov bx, 0 mov cx,4 s1: mov al, [si][bx] mov es:[di][bx], al inc bx loop s1 pop bx pop cx ;以上是复制年份 mov ax, 54h[si] mov dx, 56h[si] mov es:5h[di], ax mov es:7h[di], dx ;以上是复制总收入 mov ax, 0A8h[bx] mov es:[di+0Ah], ax ;以上是复制人数 mov dx, es:[di+7] mov ax, es:[di+5] div word ptr es:[di+0Ah];除以内存，必须指定大小 mov es:[di+0Dh],ax ;以上是计算人均收入 add bx, 2 add si, 4 add di, 16 loop s0 mov ax, 4c00h int 21h code ends end start]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[X86汇编笔记]]></title>
    <url>%2F2019%2F12%2F29%2FX86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文主要记录x86汇编学习过程 文章为了节约时间只记录了关键部分，详细的可以参见王爽的那本汇编语言。由于win10取消了debug模式，我们利用一个汇编学习软件ASMBOXhttps://share.weiyun.com/96be7efb6265e13c27592925fba724c8密码3F3i吾爱破解论坛中有资源下载链接。 进入环境后debug，然后有如下的命令R命令查看、改变CPU寄存器的内容；D命令查看内存中的内容；E命令改写内存中的内容；U命令将内存中的机器指令翻译成汇编指令；T命令执行一条机器指令；A命令以汇编指令的格式在内存中写入一条机器指令； 接下来完成一下接下来的实验任务，就能明白指令的使用。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态分析反调试apk]]></title>
    <url>%2F2019%2F11%2F30%2F%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%8F%8D%E8%B0%83%E8%AF%95apk%2F</url>
    <content type="text"><![CDATA[本文主要记录静态分析反调试apk。 把老版本IDA 目录下的android_server push 到手机/data/local/tmp目录下，用新版本IDA7.0，动态调试的时候会报错，我们把原先的替换成新版本的android_server就不会报错了。 然后注意到是32-bit的debug server,于是将IDA换成32位的。注意，调试32位的程序得用IDA的32位版，64位的程序用64位版。不然会出错。 手机开启USB调试后，连上电脑，在Terminal中输入命令来查看自己手机的cpu类型：adb shell getprop ro.product.cpu.abi]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDA动态破解登录验证]]></title>
    <url>%2F2019%2F11%2F29%2FIDA%E5%8A%A8%E6%80%81%E7%A0%B4%E8%A7%A3%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[本文主要记录用IDA动态破解登录验证。 上一篇博客采用的IDA静态破解登录验证，本文尝试使用jeb结合IDA动态破解登录验证。apk链接：https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g 密码：duv5 先将apk拖进jeb中，点击manifest查看一下是否有android:debuggable=”true”语句，如果为false我们需要将它改为true。我们查看一下反编译后的代码，发现登录验证的代码是调用native的check方法。所以我们接下来需要使用IDA对so文件进行分析。 我们使用apktool拆包，然后使用IDA打开lib\armeabi\libJniTest.soib\armeabi\libJniTest.so文件。找到check方法的进行分析，这也是以前我们采用的静态分析方法。（不会使用IDA的可以查看上一篇博客IDA爆破签名验证） 我们可以像上节课那么直接修改so的16进制来破解，这是一种思路。接下来我们使用另外一种思路，动态调试so，在程序运行的时候改变程序的跳转逻辑。 将IDAPro/dbgsrv/下的Android_server push 到手机/data/local/temp/目录下，并给它777权限，并./运行 端口转发命令 adb forward tcp:23946 tcp:23946 使用命令:adb shell am start -D -n demo2.jni.com.myapplication/demo2.jni.com.myapplication.MainActivity启动需要调试的Activity,app会弹出Waitting for debugger 启动IDA pro DIA,点击”Debugger - &gt; Attach -&gt; Remote ArmLinux/Androiddebugger”，会看到以下对话框，然后按照如图所示操作，填写ip、转发的端口 点击ok后会弹出如下框，可以使用Ctrl F查找你要调试的包名，点击ok 打开monitor,查看端口，8700端口如果被占用，我们可以使用8601 我们打开命令提示符，输入以下命令：jdb -connect com.sun.jdi.SocketAttach:port=8601,hostname=localhost 点击IDA中的继续执行按钮，就是绿色三角的按钮（F9） 在ida弹出的”Add map”窗口中，一律点击”Cancle”按钮 IDA主要功能窗口如下图所示 因为我们没有设置断点，我们发现手机上已经不再是waitting for debug了，已经到了登录界面。在Modules中，我们可以按ctrl F,搜索我们要找的libjniTest.so 点击IDA中的暂停调试按钮，暂停当前的调试，如下图所示： 右击libJniTest.so文件，在弹出的框中点击”Jump to module base”,跳转到libJniTest.so文件的起始地址。按下Alt+T，弹出查找对话框中输入” Java_demo2_jni_com_myapplication_myJNI_check ” 。 也可以在Modules双击so文件，里面就会显示so函数方法的列表，找到check方法并点击，查看Debug窗口的汇编代码。（两种方法都可以找到check方法） 按F5将ARM汇编转换成c语言，设置UTF-8编码，导入jni.h文件并优化代码的可读性 通过IDA静态分析的时候可以看到里面的strcmp方法，这里没有显示出来，我们选中点进去，之后按住p键创建函数，成功后按Esc返回 F5转换成C语言后 再按一次F5键刷新一下代码 这里可以看到程序已经识别出来了strcmp函数 按Esc键返回到汇编视图 分析check函数汇编 可以看到三处strcmp分别是校验签名,用户名,和密码是否正确 由于我用的是原包测试所以这里签名是正确的 这里在校验用户名和密码处的strcmp分别下一个断点。 按F9运行程序 然后在手机正在运行的黑宝宝程序随便输入一个用户名和密码 用户名:pzb2019 密码:123456 点击登录 看到程序断在了第一个strcmp处 此时R0和R1寄存器分辨是strcmp函数的两个参数 鼠标先点击Hex View-1窗口 然后再点击R0寄存器后面的跳转地址 即可在Hex窗口中看到我刚刚输入的pzb2019和寄存器R1储存正确的用户名koudai。到这一步我们已经学会了用IDA动态调试apk了。 接下来我们尝试破解 第一种方法:我们先F8单步调试，我们发现R0寄存器的值不为0,我们选中右键把它置为0，强制让strcmp返回0 然后F9运行程序，下面修改密码的strcmp同理， 可以看到手机弹出登陆成功。 第二种方法:我们直接修改内存16进制破解。我们运行到第一个strcmp，我们可以把看到R1寄存器对应地址存的正确用户名koudai所对应的16进制为6B 6F 75 64 61 69 ，R0寄存器中我们输入的用户名pzb2019对应的16进制为70 7A 62 32 30 31 39。 我们尝试将R0寄存器内存地址存的内容改为R1内存中正确的用户名。R0寄存器中，右键选中进行编辑，改为6B 6F 75 64 61 69，最后用00结束，修改后右键应用即可。我们单步执行F8也可以看到R0置0了。 校验密码修改与之同理，修改完后，F9运行程序，手机就会弹出登录成功。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统读书笔记]]></title>
    <url>%2F2019%2F11%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文主要记录学习计算机操作系统的心得。 第一章操作系统作用：1、OS作为用户与计算机硬件系统之间的接口2、OS作为计算机系统资源的管理者3、OS实现了对计算机资源的抽象 操作系统发展过程：1、人工操作系统2、单道批处理系统由于系统对作业的处理都是成批地处理的，且在内存中保持一道作业，故称此系统为单道批处理系统。3、多道批处理系统用户提交的作业都存放在外存上并排列成一个队列，称为“后备队列”；然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使他们共享CPU和系统中的各种资源。4、分时系统分时系统与多道批处理系统之间有着截然不同的性能差别，他能很好的将一台计算机提供给多用户使用，提高计算机得利用率。5、实时系统系统能及时响应外部事件的请求，在规定的时间内完成对事件的处理，并控制所有实时任务协调一致地运行。6、微机操作系统(1)单用户单任务操作系统CP/MMS-DOS(2)单用户多任务操作系统Windows(3)多用户多任务操作系统UNIX OSUNIX的变型Solaris OS和Linux OS 操作系统的基本特性：1、并发性并行和并发的区别进程和线程进程是指在系统中能独立运行并作为资源分配的基本单位进程作为资源分配的基本单位，而线程作为独立运行和独立调度的基本单位。由于线程比进程小，基本上不拥有系统资源，故对他调度所付出的开销就会小很多。2、共享性3、虚拟技术时分复用、空分复用4、异步性、进程是以人们不可预知的速度向前推进，此即进程的异步性。但只要操作系统中配置完善的进程同步机制，且运行环境相同，作业经过多次运行都会获得相同的结果。因此，异步运行方式是允许的，而且是操作系统的一个重要特征 操作系统的主要功能1、处理机管理功能进程控制进程同步进程通信调度2、存储器管理功能内存分配内存保护地址映射内存扩充3、设备管理功能缓冲管理设备分配设备处理4、文件管理功能文件存储空间的管理目录管理文件的读/写管理和保护5、操作系统与用户之间的接口用户接口程序接口 第二章进程是资源分配和独立运行的基本单位 进程的三种基本状态1、就绪状态当进程分配到除了cpu以外的所有必要资源后，只要再获得CPU，便可以立即运行，进程这时的状态称为就绪状态。2、执行状态3、阻塞状态在不少系统中只有上述三种状态，另外一些系统增加了一些新状态。4、挂起状态5、创建状态和终止状态 进程控制块PCB(Process Control Block),他是进程实体的一部分，是操作系统中最重要的记录型数据结构。PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发的进程。 进程控制块中主要包含下述四方面的信息进程标识符处理机状态进程调度信息进程控制信息 进程控制块的组织方式链接方式索引方式 进程控制一般是由OS的内核中的原语来实现的。原语是由若干条指令组成的，用于完成一定功能的一个过程。它与一般过程的区别是：它们是“原子操作”。原子操作：指一个操作中的所有动作，要不全做，要不全不做。它是一个不可分割的基本单位，在执行过程中不允许被中断。原子操作在管态下执行，常驻内存。原语的作用是为了实现进程的通信和控制，系统对进程的控制如果不使用原语，就会造成其状态的不确定性，从而达不到进程控制的目的。]]></content>
      <categories>
        <category>计算机技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓逆向的基础命令]]></title>
    <url>%2F2019%2F11%2F28%2F%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%AE%89%E5%8D%93%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本文主要介绍一下电脑连接手机后一些基本命令的操作。 1、把电脑的文件传到手机中因为手机中没有temp文件夹,需要建一个temp文件夹。(#后面为注释)adb shell #进入手机su #把权限升级为rootcd /data/data#进入目录下mkdir temp#创建一个文件夹chmod -R 777 temp#给temp文件夹权限我们退出手机，使用命令：adb push D:/3/1.test /data/data/temp/成功将文件发到手机 2、把手机中的文件传送到电脑adb pull /data/local/temp/1.txt D:/3/ 3、pull出包下的所有的文件这里以/data/data/目录下的demo2.jni.com.myapplication包pull到电脑D:/3目录下为例。由于将包全部拉到电脑中需要权限，所以跟上面相似，现需要进入手机给包demo2.jni.com.myapplication权限命令：adb shellsucd /data/data/chmod -R 777 demo2.jni.com.myapplication然后我们exit,退出手机命令：adb pull /data/data/demo2.jni.com.myapplication/. D:/3/ 4、创建文件test.txt 5、创建文件夹 6、删除文件test.txt 7、删除文件夹dir 8、将apk安装在手机上 9、重命名文件1.txt]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jeb工具的使用]]></title>
    <url>%2F2019%2F11%2F28%2Fjeb%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文主要记录jeb工具的常用功能。 一、下面将会从以下几个方面介绍jeb的常用功能1.反编译apk,dex2.包名树状图3.查看指定类的smali代码4.转换成java语言5.java代码中双击函数 进入函数方法的定义 ，查看方法的调用6.查看AndroidManifest.xml我们首先使用apktool反编译，得到了反编译后的文件夹app-debug 二、工具的使用1、打开JEB软件，并把crack04.apk拖拉到JEB中即可反编译apk，双击Bytecode打开smali代码。 2、点击Bytecode/Hierarchy窗口即可查看包名树状图 树状图排列: 包名-&gt;类名。 3、双击包名下的类名即可查看smali代码 4、想把指定区域的smali代码转换成java代码,很简单,只需右键Q即可 5、双击方法即可跳转到方法的定义 点击方法按x键可以查看方法的调用 6、双击Manifest即可查看AndroidManifest.xml 7、搜索功能可以搜索函数、字符串等]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDA破解账号密码]]></title>
    <url>%2F2019%2F11%2F28%2FIDA%E7%A0%B4%E8%A7%A3%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本文主要记录用IDA破解账号密码。 本文是接着上一篇爆破签名验证的工作进一步深入，尝试爆破一下账号和密码。前面的处理代码的步骤完全一致，我们不再接着赘述，我们接着尝试爆破一下他的账号和密码。apk链接：https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g 密码：duv5 我们查看汇编界面的图形界面，我们发现上次是修改一个判断绕过签名验证，同理我们是否能修改下面代码中的判断语句来随便输入账号和密码就能登录成功呢？ 我们看到上图中两个判断语句，我们先修改第一个，将BNE改为BEQ。 再修改第二个判断的语句，将BEQ改为BNE。 保存so文件，然后替换掉原先armeabi和armeabi-v7a里面的so文件。 然后重新打包，签名安装。 总结一下：首先要找到java所调用的native层的方法，再通过汇编代码、c理解代码逻辑，当中可以使用汇编的图形界面，可以快速帮助我们理解代码结构。往往需要修改的地方都是一些判断的语句，注意一下这些地方，可以很快的帮助到我们。特别感谢吾爱破解论坛，我也是跟着论坛中的教学一步一步学习的，希望可以一步一个脚印把知识学扎实。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDA爆破签名验证]]></title>
    <url>%2F2019%2F11%2F28%2FIDA%E7%88%86%E7%A0%B4%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[本文主要记录用IDA爆破签名验证。 爆破的Demo是一款黑宝宝apk，他设置了签名验证，如果你反编译后重新打包签名，他会将该签名与原签名就行对比，你安装在手机上之后一打开程序则会退出。看一下代码发现签名验证是写在so里面的。接下来爆破他的签名验证。apk链接：https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g 密码：duv5 用apktool解包apk,然后用IDA打开libJniTest.so。 文件中有Imports表和Exports表Imports是导入表，so中调用的外面的函数。Exports是导入表，so中能让外部调用的函数。我们在java层可以知道调用了一个native层的函数check，然后Exports表记录了so中被外部调用的函数，而且我们清楚so中的函数都是以java_包名_类名_方法名的格式所命名。那么我们直接在Exports表中搜索check,就可以搜到该函数。 我们找到check函数后双击它进入check方法。 我们按F5将汇编语言变为c语言。 我们发现存在一些乱码，我们按alt+a键，将如图所示编码改为UTF-8。点击ok后，再重新刷新之后就可以发现乱码没有了。 乱码问题虽然解决了 但是下面的代码可读性很差 此时需要导入jni.h文件,点File-&gt;Load file-&gt;Parse C header file,找到jni.h所在位置点击打开,此时显示Compilation successful导入成功。下载链接：https://pan.baidu.com/s/1n16NEx67zLHfGtVpU-CKAA 密码：7xg6 我选中第一个int,右键选择Convert to struct*，选择_JNIEnv,点击ok,我们发现有一些函数已经显示出来了。 但是函数的可读性还是差了一些，我们选中函数GetStringUTFChars,右键选择force call type，其他的函数也同样这样，之后我们发现代码的可读性提高了。 我们点选中a1,然后按n键重命名为env，至于为什么这样做，不是这节课的重点，以后的博客中会讲到。 现在我们回到汇编视图，按空格键就可以切换到图形视图。图形视图我们可以一目了然的看清代码结构，我们也可以按住ctrl滑鼠标的滑轮来调节视图的大小。 我们可以看到判断签名的代码。调用strcmp函数来比较现在的签名和原来的签名是否一致，如一致R0标志位置为0，比较标志位置是否为0，为0程序走左视图，不为0走右视图。 我们想要让他通过，很显然，我们把BNE(不等于0)修改为BEQ(等于0)，这样我们修改完签名后，程序就会走左视图，就不会因为签名验证不能正常运行程序。我们鼠标选中BNE，然后按空格键切换回汇编视图，选中BNE,然后点击View-&gt;open subview-&gt;hex dump。 然后我们可以看到BNE对应的16进制，我们只需要将BNE的16进制改为BEQ的16进行就成功了。BNE是D1,BEQ是D0，我们修改后保存就修改成功。 返回到汇编视图也可以看到修改成功。 我们保存修改后的so文件。我们将修改后的so文件替换掉原先armeabi和armeabi-v7a里面的so文件。 重新打包，签名，安装到手机就可以正常的运行了。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的几种编码方式]]></title>
    <url>%2F2019%2F11%2F28%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文记录了字符常见的几种编码方式 无论在是在编辑文本文件的时候，还是在制作网页的时候，总会遇到文本编码方式的问题。如果处理不当，就会出现乱码的问题。因此，有必要对文本的编码方式做一个详尽的了解。常见的一些字符编码方式无非有：Unicode、ASCII、GBK、GB2312、UTF-8。下面先对常见的这一些字符编码方式作下说明： 1.ASCII码这是美国在19世纪60年代的时候为了建立英文字符和二进制的关系时制定的编码规范，它能表示128个字符，其中包括英文字符、阿拉伯数字、西文字符以及32个控制字符。它用一个字节来表示具体的字符，但它只用后7位来表示字符（2^7=128），最前面的一位统一规定为0。 2.扩展的ASCII码原本的ASCII码对于英文语言的国家是够用了，但是欧洲国家的一些语言会有拼音，这时7个字节就不够用了。因此一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使 用的编码体系，可以表示最多256个符号。但这时问题也出现了：不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码 中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。这个问题就直接促使了Unicode编码的产生。 3.Unicode符号集正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。而Unicode就是这样一种编码：它包含了世界上所有的符号，并且每一个符号都是独一无二的。比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表 。很多人都说Unicode编码，但其实Unicode是一个符号集（世界上所有符号的符号集），而不是一种新的编码方式。但是正因为Unicode包含了所有的字符，而有些国家的字符用一个字节便可以表示，而有些国家的字符要用多个字节才能表示出来。即产生了两个问题：第一，如果有两个字节的数据，那计算机怎么知道这两个字节是表示一个汉字呢？还是表示两个英文字母呢？第二，因为不同字符需要的存储长度不一样，那么如果Unicode规定用2个字节存储字符，那么英文字符存储时前面1个字节都是0，这就大大浪费了存储空间。上面两个问题造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode在很长一段时间内无法推广，直到互联网的出现。 4.UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8的编码规则很简单，只有两条：1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 5.GBK/GB2312/GB18030GBK和GB2312都是针对简体字的编码，只是GB2312只支持六千多个汉字的编码，而GBK支持1万多个汉字编码。而GB18030是用于繁体字的编码。汉字存储时都使用两个字节来储存。 总的来说：ASCII编码：用来表示英文，它使用1个字节表示，其中第一位规定为0，其他7位存储数据，一共可以表示128个字符。拓展ASCII编码：用于表示更多的欧洲文字，用8个位存储数据，一共可以表示256个字符GBK/GB2312/GB18030：表示汉字。GBK/GB2312表示简体中文，GB18030表示繁体中文。Unicode编码：包含世界上所有的字符，是一个字符集。UTF-8：是Unicode字符的实现方式之一，它使用1-4个字符表示一个符号，根据不同的符号而变化字节长度。 详细链接：http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.htmlhttps://blog.csdn.net/byf0521hlyp/article/details/80365045]]></content>
      <categories>
        <category>计算机技术</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDA破解第一个so]]></title>
    <url>%2F2019%2F11%2F27%2FIDA%E7%A0%B4%E8%A7%A3%E7%AC%AC%E4%B8%80%E4%B8%AAso%2F</url>
    <content type="text"><![CDATA[本文主要记录用IDA破解第一个so 首先下载工具IDA。链接：https://pan.baidu.com/s/15uCX8o6tTSSelgG_RN7kBQ密码：ftie 本文所用到的Demo是上个博客所生成的so文件。链接：https://pan.baidu.com/s/1vKC1SevvHfeI7f0d2c6IqQ密码：u1an 我们首先使用apktool反编译，得到了反编译后的文件夹app-debug 然后我们打开文件夹找到lib文件，可以看到里面有基于不同cpu的so文件。因为我的机型是支持arm的所以我这里打开的是armeabi文件夹下的so，如果机型是x86模式的那么这里要打开x86模式下的libJniTest.soarmeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的大部分Android设备都使用它.arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。x86: 平板、模拟器用得比较多。x86_64: 64位的平板。 我们现在打开下载好的的IDA，遇到的弹窗全部选择ok。我们用IDA打开so文件。 我们按住shift+f12打开字符串窗口 这个窗口将会列举出so中所包含的所有字符串 我们只编写了一个字符串 所以这里只有一个hello byx! 如果打开的是x86的so这里还会有一些.so 但是字符串只有这一个。 我们双击字符串点进去如图所示，我们可以看到字符串对应的内存地址00001DF8。 我们把鼠标放在hello byx上，点击工具栏里面的View-&gt;opensubview-&gt;hex dump 然后我们可以看到对应内存地址上的内容。关于字符对应的16进制可以搜索ascii表，找到字符对应的16进制。 我们尝试把hello byx 改为hello pzb。我们利用在线ascii转换工具分别转换这两个字符串。 我们在IDA中右键选择编辑。将62 79 78改为 70 7a 62 然后我们再右键选择apply changes 我们选择edit-&gt;plugins-&gt;modifyfile来保存修改后的so。 我们确定修改并将修改后的so单独的放在一个位置。 我们将IDA关闭，然后将修改后的so替换armeabi文件夹和armeabi-v7a文件下的so文件。然后我们重新打包app-debug。然后打开AndroidKiller为打包好的apk进行签名。 然后我们使用adb install D:\apk\破解so\test_sign.apk安装apk 我们打开AndroidStudio查看打印的log。成功修改！]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apktool的使用]]></title>
    <url>%2F2019%2F11%2F27%2Fapktool%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文主要介绍一下apktool的使用 一、下载最新版apktool,官网链接:https://ibotpeaches.github.io/Apktool/ 二、配置apktool1.将下载好的apktool重命名为apktool.jar 并下载apktool.bat 下载链接：https://pan.baidu.com/s/1ClEDZ1yiUobG46sQtaSY8Q 密码：gofa2.将下载的apktool重命名为apktoool.jar 并把apktool.bat一起放到C:\Windows目录下 按住快捷键win+R,输入cmd快捷键打开cmd命令窗口,输入apktool,配置成功显示如下: apktool 常用的两个命令如下解包：apktool d test.apk重新打包：apktool b test -o testc.apk 解压的text文件夹是解包后的文件夹 在这里我们可以修改apk里面的一些文件 那么testc.apk就是重打包后的apk以下以上一篇博客AndroidStudio编写第一个so编写出的app-debug.apk测试为例子 1.cd 进入apk所在目录 输入解包命令解包成功会在当前目录下生成app-debug文件夹apktool d app-debug.apk 2.输入重打包命令 -o是重命名apktool b app-debug -o testc.apk 打开命令窗口输入adb install apk文件 发现安装失败提示了Failure [INSTALL_FAILED_TEST_ONLY]这个错误 这个错误有两个解决办法：第一种：在安装命令中加入-t.即adb install -t D:\AndroidStudioProjects\TestJni2\app\build\outputs\apk\debug\testc.apk 第二种：修改AndroidManifest.xml文件，把android:testOnly=”true”改成android:testOnly=”false”或者删掉这一行。 我们就用第一种方法安装，发现安装又出现了错误：Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES]它提示没有签名。我们打开AndroidKiller-工具-apk签名，把需要签名的testc.apk拖进去，进行签名 签名完成后，在testc.apk同目录的文件夹下生成一个签名后的apk文件 签名后我们再进行apk的安装，这次就顺利安装成功！]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio编写第一个so]]></title>
    <url>%2F2019%2F11%2F26%2FAS%E7%BC%96%E5%86%99%E7%AD%89%E4%B8%80%E4%B8%AAso%2F</url>
    <content type="text"><![CDATA[本文主要记录用AndroidStudio编写第一个so 打开AndroidStudio新建一个Android项目，在包里面建一个普通的java类，里面写上如图所示的代码。里面有一个sayhello的方法和一个加载so库的静态初始化块。静态初始化块中的JniTest是我们提前给so库名。我们发现方法标红，是因为没有生成对应的头文件和so库，我们下一步就会完成这些 我们使用命令行在java目录下执行javah -d ../jni 包名.类名，会在java上一级目录中生成一个jni文件夹（该文件夹与java同级）,文件夹中存放的就是.h的头文件。 接着在jni文件夹中创建一个main.c文件，把.h的头文件导入进去，把sayhello方法在main.c中实现。 把下载的ndk环境与AndroidStudio关联起来，local.properties也会显示出ndk的路径。 打开app Module的build.gradle文件，在defaultConfig节点里添加以下代码 注意这里的moduleName，是我们在之前自己编写的类里面加载的so库名。 ndk { moduleName &quot;JniTest&quot; ldLibs &quot;log&quot;, &quot;z&quot;, &quot;m&quot; abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot; } 还要在gradle.properties里面加上这么一句话：android.useDeprecatedNdk=true 接下来直接rubuild project 发现出现了错误，修改gradle.properties里面这一句话：android.useDeprecatedNdk=true，按照如图所示修改，就成功了 可能出现这种错误，在jni文件夹下建一个.c的空文件夹就可以解决。（该错误时不时的会出现，具体原因以后再把它搞清楚） 我们rebuild一下就可以生成so库了 生成的so在项目的app\build\intermediates\ndk\debug\lib路径下 我们可以在main目录下建立一个jniLIB,然后把lib里面的文件复制过来。 so库生成完毕，现在我们在Mainactivity中打印MyJBI中的sayhello()。成功实现！]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Smali代码中插入Log]]></title>
    <url>%2F2019%2F11%2F24%2FSmali%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%8F%92%E5%85%A5Log%2F</url>
    <content type="text"><![CDATA[本文主要介绍在Smali代码中插入Log。 这里我编写了一个Demo 从下面的代码中可以看出我在onCreate方法中执行了三个函数 函数名分别是fun1 fun2和fun3 并且在下面加入一条Log 目的是为了打印出函数fun1的返回值 因为Log.i的两个参数都必须是String类型 所以这里把int类型的fun1这个函数通过String.valueOf函数转换成String类型 public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); fun1(); fun2(); fun3(); Log.i(&quot;这个值是&quot;,String.valueOf(fun1())); } public int fun1() { int value = Test.value; return value; } public int fun2() { int value2 = Test.value2; return value2; } public String fun3() { String str = Test.str; String str2 = Test.str2; int value3 = Test.value3; return str2; } } 接下来我们需要完成以下三个任务：任务一添加Log打印出fun2,fun3的值 (其实就是函数的返回值)任务二添加Log打印出fun3里面String类型str的值任务三添加Log打印出fun3里面int类型value3的值 首先我们来完成任务一。我们先来打印fun2的值，我们发现原来已经打印过fun1的值了，fun2和fun1函数返回值类型都一样，都需要调用String.valueOf()来转化为int类型，那我们打印fun2就很简单了，只需要找到fun1的打印语句的代码，换成fun2就成功了。 我们现在来打印fun3的值，我们发现fun3的返回值直接就是String类型的，我们只需要将上面fun1和fun2的代码中的fun1改为fun3，并将返回值类型改为String，并且将类型转换的代码删掉就成功了。任务一就成功完成了 现在来完成第二个任务，打印fun3中String类型的str的值。我们直接找到fun3方法中的str值，他一定会将str的值放到一个寄存器中，我们找到这个寄存器，然后打印出他的值就成功了，顺利完成任务二。 现在我们来完成任务三，我们思路跟任务二相同，在fun3方法中找到存放value3的寄存器，然后尝试把他打印出来。 本节课从简单的插入Log到从smali代码中打印变量的值,然后从中牵扯到了类型转换,最后通过完成三条任务为主线,每一个例子 每一个点都很精致并且实用,这节课的内容可以留着当做Log方面参考文档 虽然本节课的篇幅比较长 但是所讲的所有东西,最好自己能有一些心得。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态调试Smali代码]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95Smali%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本文主要介绍一下利用Android Studio动态调试Smali代码 第一步：我们使用上一次自己编写的一个简单的登录界面的apk，我们先把这个apk扔到AndroidKiller里面，反编译这个apk。 我们通过AndroidManifest.xml文件找到程序的包名和入口 我们查看AndroidManifest.xml是否存在android:debuggable=”true”这句代码，没有是不能调试apk的 现在调试的这个例子默认是有这句代码的 有的apk中没有这句代码要自行添加上有是不能调试apk的。 第二步：然后我们使用命令adb install apk文件 将apk安装到手机中，打开usb调试模式。 第三步：然后我们打开Smali文件所在的位置，把Smali代码复制到新建的D盘下的一个单独的jwx02文件夹中，并改名为src。 第四步：在AndroidStudio设置中需要安装好Smalidea插件，如果是已经默认安装好的就不用再安装了。 第五步：导入jwx02这个文件到AndroidStudio中。点击File之后选择import project，然后把刚才单独创建的jwx02文件夹导入进来。 第六步：然后将src目录设置为sources root,这一步告诉AndroidStudio这个文件夹下的是源代码。 第七步：接下来配置远程调试选项。选择Run–&gt;Edit Configurations 并增加一个Remote调试的调试选项，端口选择:8700。 第八步：配置JDK。选择File–&gt;Project Structure 配置JDK 第九步：打开Android Device Monitor 第十步：打开cmd,输入命令adb shell am start -D -n hfdcxy.com.myapplication/hfdcxy.com.myapplication.MainActivity 对apk进行动态调试 这条命令运行后手机屏幕将会进入到调试界面(如果手机屏幕没有进入到调试界面说明USB没有连接好手机 或者USB调试模式 没有打开 或者其他原因) 第十一步：打开AndroidStudio,对希望查看的关键代码下断点，之后点击Run,选择debug smali，这里smali是我们之前配置好的调试选项。此时手机会进入程序 在手机上输入用户名和密码 点登陆 程序会断在我下的断点处。F8执行下一步，F9运行程序。 其中第一、二步是查看反编译后的代码，并将apk安装到手机中。第三步到第八步是将反编译后的smali代码导入到AndroidStudio中，并且配置好相关的环境（sources root、Remote、JDK）第九步到第十一步是使用命令对手机开始进行动态调试。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[火柴人联盟]]></title>
    <url>%2F2019%2F11%2F18%2F%E7%81%AB%E6%9F%B4%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[本文主要记录破解火柴人联盟游戏的思路。 安装火柴人游戏玩一下，发现游戏里面有商城，商城里面提供了需要购买的道具，还有一些礼包也需要购买，英雄也需要购买，支付方式分为了话费支付、三方支付。 我们尝试一下搜索一下关键的字符：支付失败、支付成功我们在查询过程中就可以看到支付信息代码所在的文件目录，我们一一打开，发现有短信、联通、移动、电信几种支付方式 我们可以看到关于支付信息的代码 我们先打开联通的支付，smali代码如下，就是一个简单的switch语句，我们将支付取消和支付失败的switch语句调用全部改为支付成功的情况。 我们在点击电信的支付信息，可以看到电信相关的支付成功的方法、支付失败的方法、支付取消的方法。我们使用最简单的方法，将支付失败和支付取消里面的代码全部改为支付成功的代码 我们在看一下移动支付的代码，和联通的基本一样，也是switch语句，我们还是果断使用switch大法，成功解决。 最后还有一部分去广告，同意支付接口的一系列操作后面再补充。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切水果大战]]></title>
    <url>%2F2019%2F11%2F18%2F%E5%88%87%E6%B0%B4%E6%9E%9C%E5%A4%A7%E6%88%98%2F</url>
    <content type="text"><![CDATA[本文主要记录破解切水果大战游戏的思路。 拿到这一款切水果游戏，首先安装到手机上玩一下。命令：adb install apk文件体验之后发现一般的道具消费都会提示充值金币，没有充值的话会提示失败我们尝试破解 将APK文件拖到Android Killer 进行反编译，我们看到反编译后的文件我们尝试进行关键字搜索“失败”我们会发现关于支付的代码。 我们浏览代码，可以看java代码，如果对smali代码熟练的话直接看smali 代码，我发现了支付失败的方法、支付成功的方法、支付取消的方法。 接下来我们尝试用三种方法进行破解第一种方法：我们找到了代码中支付失败、支付取消和支付成功的代码，我们可以直接将支付失败和支付取消的方法中的代码全部改为支付成功的代码。第二种方法：第一种方法是直接改支付失败里面的代码，将他们改成支付成功，这是一种思路，我们现在尝试第二种方法，尝试看一下支付失败的代码是在哪里被调用的。我们尝试搜索payResultFalse()方法，搜索到调用payResultFalse()的文件，如图所示，我们发现了调用支付失败和支付成功的位置，我们把调用支付失败的方法改成调用支付成功的方法。破解成功。第三种方法，我们修改switch分支，把:pswitch_1修改为:pswitch_0，这样代码只会跳转到支付成功的方法处，破解成功。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名网络Tor与I2P的比较研究]]></title>
    <url>%2F2019%2F11%2F08%2F%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9CTor%E4%B8%8EI2P%E7%9A%84%E6%AF%94%E8%BE%83%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[本文主要记录匿名网络Tor与I2P的主要区别。 Tor（the onion router）是部署最多的匿名通信系统，提供在线匿名和隐私保护，而隐形互联网I2P（invisible Internet project）允许应用程序通过使用大蒜路由，以匿名和安全方式相互发送消息。 Tor与I2P使用术语与一些关键区别： Tor匿名网络 I2P匿名网络 基于电路的低延迟覆盖网络 基于分组的高延迟重叠网络 允许匿名访问分别实施和操作外部互联网服务 试图将现有的互联网服务转移到I2P网络，并在框架内提供服务实现 双向电路 单向通道 集中式框架 分布式架构 使用Socket Secure（SOCKS）接口，只能通过TCP传输消息 I2P 是一个中间件，提供应用程序可用于通过网络进行通信的API，可以在UDP和TC之间进行选择 Cell，细胞 Message，消息 Client，客户 Router、Clients，路由器或客户端 Circuit，电路 Tunnel，隧道 Directory，目录 Net DB，网络数据库 directory server，目录服务器 floodfill router，floodfill 路由器 Entry guard，入境卫兵 Fast peer，快速对等体 Ingress node，入口节点 Inproxy，入口代理 exit node，退出节点 Outproxy，出口代理 hidden service，隐藏服务 Eepsite or destination，Eepsite 或目的地 hidden service descriptor，隐藏服务描述符 lease set，租约集 introduction point，介绍点 inbound gateway，入站网关 onion routing，洋葱路由 garlic routing，大蒜路由 Node、Server，节点、服务器 Router，路由器 Onion agent，洋葱代理 I2P Tunnel 客户端 Onion service，洋葱服务 隐藏服务，Eepsite 或目的地 Rendezvous Point，会合点 Inbound Gateway+Outbound Endpoint，入站/出站网关 Router descriptor，路由器描述符 Routerinfo，路由器信息 Tor和I2P开发技术比较： 特征 域名 节点选择标准 目录服务器/floodfill 对等体 分组/电路交换 单向/双向 保护以免检测客户端活动 隧道/电路的期限 TCP/UDP传输 SOCKS/ I2P API Tor .onion 信任、声明、能力 信任和硬编码 电路交换 双向电路 较少保护 时间长 TCP SOCKS I2P .i2p 不断分析和排名性能 多变且不可信 分组交换 单向隧道 较多保护 时间短 两者都可以 I2P API]]></content>
      <categories>
        <category>网络安全</category>
        <category>计算机技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>匿名网络</tag>
        <tag>流量识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登山赛车破解]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%99%BB%E5%B1%B1%E8%B5%9B%E8%BD%A6%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文主要记录破解登山赛车游戏的思路。 下载好apk ,放入模拟器中试玩一下，我们点击购买金币，不支付的话会提示购买失败。 我们可以看到付款失败特别明显，我们可以把apk拖进android killer里面搜索一下付款 失败的字符，找到提示付款失败的代码。 可以看到是一个switch语句，我们找到添加金币的代码。 这里是付款失败的代码块 下面两端代码块是添加的金币的代码块。 我们尝试把它拖到最下面，可以看到这样的代码。 我们将两个都改为:pswitch_0。 编译完成，再拖入模拟器里面试一下 成功获取金币，破解成功。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解糖果星星达人]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%A0%B4%E8%A7%A3%E7%B3%96%E6%9E%9C%E6%98%9F%E6%98%9F%E8%BE%BE%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[本文主要记录破解糖果星星达人游戏思路。 试玩一下糖果星星达人，尝试一下破解金币。把apk 扔到模拟器里面玩一下，还是蛮好玩的，反正死了就要让你充值金币，我们任意输入他提示购买失败，我们尝试一下破解。试着将apk扔进Android Killer里面，搜过一下关键字“购买失败” 很简单，就是个switch语句，上下浏览一下，找到购买成功 我们还看到了购买取消，我们拖到最下面，尝试把5、6改成4，看能否成功 重新编译，放入模拟器中，购买成功。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
</search>
