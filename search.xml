<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AndroidStudio编写第一个so]]></title>
    <url>%2F2019%2F11%2F26%2FAS%E7%BC%96%E5%86%99%E7%AD%89%E4%B8%80%E4%B8%AAso%2F</url>
    <content type="text"><![CDATA[本文主要记录用AndroidStudio编写第一个so 打开AndroidStudio新建一个Android项目，在包里面建一个普通的java类，里面写上如图所示的代码。里面有一个sayhello的方法和一个加载so库的静态初始化块。静态初始化块中的JniTest是我们提前给so库名。我们发现方法标红，是因为没有生成对应的头文件和so库，我们下一步就会完成这些 我们使用命令行在java目录下执行javah -d ../jni 包名.类名，会在java上一级目录中生成一个jni文件夹（该文件夹与java同级）,文件夹中存放的就是.h的头文件。 接着在jni文件夹中创建一个main.c文件，把.h的头文件导入进去，把sayhello方法在main.c中实现。 把下载的ndk环境与AndroidStudio关联起来，local.properties也会显示出ndk的路径。 打开app Module的build.gradle文件，在defaultConfig节点里添加以下代码 注意这里的moduleName，是我们在之前自己编写的类里面加载的so库名。 ndk { moduleName &quot;JniTest&quot; ldLibs &quot;log&quot;, &quot;z&quot;, &quot;m&quot; abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot; } 还要在gradle.properties里面加上这么一句话：android.useDeprecatedNdk=true 接下来直接rubuild project 发现出现了错误，修改gradle.properties里面这一句话：android.useDeprecatedNdk=true，按照如图所示修改，就成功了 可能出现这种错误，在jni文件夹下建一个.c的空文件夹就可以解决。（该错误时不时的会出现，具体原因以后再把它搞清楚） 我们rebuild一下就可以生成so库了 生成的so在项目的app\build\intermediates\ndk\debug\lib路径下 我们可以在main目录下建立一个jniLIB,然后把lib里面的文件复制过来。 so库生成完毕，现在我们在Mainactivity中打印MyJBI中的sayhello()。成功实现！]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Smali代码中插入Log]]></title>
    <url>%2F2019%2F11%2F24%2FSmali%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%8F%92%E5%85%A5Log%2F</url>
    <content type="text"><![CDATA[本文主要介绍在Smali代码中插入Log。 这里我编写了一个Demo 从下面的代码中可以看出我在onCreate方法中执行了三个函数 函数名分别是fun1 fun2和fun3 并且在下面加入一条Log 目的是为了打印出函数fun1的返回值 因为Log.i的两个参数都必须是String类型 所以这里把int类型的fun1这个函数通过String.valueOf函数转换成String类型 public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); fun1(); fun2(); fun3(); Log.i(&quot;这个值是&quot;,String.valueOf(fun1())); } public int fun1() { int value = Test.value; return value; } public int fun2() { int value2 = Test.value2; return value2; } public String fun3() { String str = Test.str; String str2 = Test.str2; int value3 = Test.value3; return str2; } } 接下来我们需要完成以下三个任务：任务一添加Log打印出fun2,fun3的值 (其实就是函数的返回值)任务二添加Log打印出fun3里面String类型str的值任务三添加Log打印出fun3里面int类型value3的值 首先我们来完成任务一。我们先来打印fun2的值，我们发现原来已经打印过fun1的值了，fun2和fun1函数返回值类型都一样，都需要调用String.valueOf()来转化为int类型，那我们打印fun2就很简单了，只需要找到fun1的打印语句的代码，换成fun2就成功了。 我们现在来打印fun3的值，我们发现fun3的返回值直接就是String类型的，我们只需要将上面fun1和fun2的代码中的fun1改为fun3，并将返回值类型改为String，并且将类型转换的代码删掉就成功了。任务一就成功完成了 现在来完成第二个任务，打印fun3中String类型的str的值。我们直接找到fun3方法中的str值，他一定会将str的值放到一个寄存器中，我们找到这个寄存器，然后打印出他的值就成功了，顺利完成任务二。 现在我们来完成任务三，我们思路跟任务二相同，在fun3方法中找到存放value3的寄存器，然后尝试把他打印出来。 本节课从简单的插入Log到从smali代码中打印变量的值,然后从中牵扯到了类型转换,最后通过完成三条任务为主线,每一个例子 每一个点都很精致并且实用,这节课的内容可以留着当做Log方面参考文档 虽然本节课的篇幅比较长 但是所讲的所有东西,最好自己能有一些心得。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态调试Smali代码]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95Smali%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本文主要介绍一下利用Android Studio动态调试Smali代码 第一步：我们使用上一次自己编写的一个简单的登录界面的apk，我们先把这个apk扔到AndroidKiller里面，反编译这个apk。 我们通过AndroidManifest.xml文件找到程序的包名和入口 我们查看AndroidManifest.xml是否存在android:debuggable=”true”这句代码，没有是不能调试apk的 现在调试的这个例子默认是有这句代码的 有的apk中没有这句代码要自行添加上有是不能调试apk的。 第二步：然后我们使用命令adb install apk文件 将apk安装到手机中，打开usb调试模式。 第三步：然后我们打开Smali文件所在的位置，把Smali代码复制到新建的D盘下的一个单独的jwx02文件夹中，并改名为src。 第四步：在AndroidStudio设置中需要安装好Smalidea插件，如果是已经默认安装好的就不用再安装了。 第五步：导入jwx02这个文件到AndroidStudio中。点击File之后选择import project，然后把刚才单独创建的jwx02文件夹导入进来。 第六步：然后将src目录设置为sources root,这一步告诉AndroidStudio这个文件夹下的是源代码。 第七步：接下来配置远程调试选项。选择Run–&gt;Edit Configurations 并增加一个Remote调试的调试选项，端口选择:8700。 第八步：配置JDK。选择File–&gt;Project Structure 配置JDK 第九步：打开Android Device Monitor 第十步：打开cmd,输入命令adb shell am start -D -n hfdcxy.com.myapplication/hfdcxy.com.myapplication.MainActivity 对apk进行动态调试 这条命令运行后手机屏幕将会进入到调试界面(如果手机屏幕没有进入到调试界面说明USB没有连接好手机 或者USB调试模式 没有打开 或者其他原因) 第十一步：打开AndroidStudio,对希望查看的关键代码下断点，之后点击Run,选择debug smali，这里smali是我们之前配置好的调试选项。此时手机会进入程序 在手机上输入用户名和密码 点登陆 程序会断在我下的断点处。F8执行下一步，F9运行程序。 其中第一、二步是查看反编译后的代码，并将apk安装到手机中。第三步到第八步是将反编译后的smali代码导入到AndroidStudio中，并且配置好相关的环境（sources root、Remote、JDK）第九步到第十一步是使用命令对手机开始进行动态调试。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切水果大战]]></title>
    <url>%2F2019%2F11%2F18%2F%E5%88%87%E6%B0%B4%E6%9E%9C%E5%A4%A7%E6%88%98%2F</url>
    <content type="text"><![CDATA[本文主要记录破解切水果大战游戏的思路。 拿到这一款切水果游戏，首先安装到手机上玩一下。命令：adb install apk文件体验之后发现一般的道具消费都会提示充值金币，没有充值的话会提示失败我们尝试破解 将APK文件拖到Android Killer 进行反编译，我们看到反编译后的文件我们尝试进行关键字搜索“失败”我们会发现关于支付的代码。 我们浏览代码，可以看java代码，如果对smali代码熟练的话直接看smali 代码，我发现了支付失败的方法、支付成功的方法、支付取消的方法。 接下来我们尝试用三种方法进行破解第一种方法：我们找到了代码中支付失败、支付取消和支付成功的代码，我们可以直接将支付失败和支付取消的方法中的代码全部改为支付成功的代码。第二种方法：第一种方法是直接改支付失败里面的代码，将他们改成支付成功，这是一种思路，我们现在尝试第二种方法，尝试看一下支付失败的代码是在哪里被调用的。我们尝试搜索payResultFalse()方法，搜索到调用payResultFalse()的文件，如图所示，我们发现了调用支付失败和支付成功的位置，我们把调用支付失败的方法改成调用支付成功的方法。破解成功。第三种方法，我们修改switch分支，把:pswitch_1修改为:pswitch_0，这样代码只会跳转到支付成功的方法处，破解成功。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[火柴人联盟]]></title>
    <url>%2F2019%2F11%2F18%2F%E7%81%AB%E6%9F%B4%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[本文主要记录破解火柴人联盟游戏的思路。 安装火柴人游戏玩一下，发现游戏里面有商城，商城里面提供了需要购买的道具，还有一些礼包也需要购买，英雄也需要购买，支付方式分为了话费支付、三方支付。 我们尝试一下搜索一下关键的字符：支付失败、支付成功我们在查询过程中就可以看到支付信息代码所在的文件目录，我们一一打开，发现有短信、联通、移动、电信几种支付方式 我们可以看到关于支付信息的代码 我们先打开联通的支付，smali代码如下，就是一个简单的switch语句，我们将支付取消和支付失败的switch语句调用全部改为支付成功的情况。 我们在点击电信的支付信息，可以看到电信相关的支付成功的方法、支付失败的方法、支付取消的方法。我们使用最简单的方法，将支付失败和支付取消里面的代码全部改为支付成功的代码 我们在看一下移动支付的代码，和联通的基本一样，也是switch语句，我们还是果断使用switch大法，成功解决。 最后还有一部分去广告，同意支付接口的一系列操作后面再补充。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名网络Tor与I2P的比较研究]]></title>
    <url>%2F2019%2F11%2F08%2F%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9CTor%E4%B8%8EI2P%E7%9A%84%E6%AF%94%E8%BE%83%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[本文主要记录匿名网络Tor与I2P的主要区别。 Tor（the onion router）是部署最多的匿名通信系统，提供在线匿名和隐私保护，而隐形互联网I2P（invisible Internet project）允许应用程序通过使用大蒜路由，以匿名和安全方式相互发送消息。 Tor与I2P使用术语与一些关键区别： Tor匿名网络 I2P匿名网络 基于电路的低延迟覆盖网络 基于分组的高延迟重叠网络 允许匿名访问分别实施和操作外部互联网服务 试图将现有的互联网服务转移到I2P网络，并在框架内提供服务实现 双向电路 单向通道 集中式框架 分布式架构 使用Socket Secure（SOCKS）接口，只能通过TCP传输消息 I2P 是一个中间件，提供应用程序可用于通过网络进行通信的API，可以在UDP和TC之间进行选择 Cell，细胞 Message，消息 Client，客户 Router、Clients，路由器或客户端 Circuit，电路 Tunnel，隧道 Directory，目录 Net DB，网络数据库 directory server，目录服务器 floodfill router，floodfill 路由器 Entry guard，入境卫兵 Fast peer，快速对等体 Ingress node，入口节点 Inproxy，入口代理 exit node，退出节点 Outproxy，出口代理 hidden service，隐藏服务 Eepsite or destination，Eepsite 或目的地 hidden service descriptor，隐藏服务描述符 lease set，租约集 introduction point，介绍点 inbound gateway，入站网关 onion routing，洋葱路由 garlic routing，大蒜路由 Node、Server，节点、服务器 Router，路由器 Onion agent，洋葱代理 I2P Tunnel 客户端 Onion service，洋葱服务 隐藏服务，Eepsite 或目的地 Rendezvous Point，会合点 Inbound Gateway+Outbound Endpoint，入站/出站网关 Router descriptor，路由器描述符 Routerinfo，路由器信息 Tor和I2P开发技术比较： 特征 域名 节点选择标准 目录服务器/floodfill 对等体 分组/电路交换 单向/双向 保护以免检测客户端活动 隧道/电路的期限 TCP/UDP传输 SOCKS/ I2P API Tor .onion 信任、声明、能力 信任和硬编码 电路交换 双向电路 较少保护 时间长 TCP SOCKS I2P .i2p 不断分析和排名性能 多变且不可信 分组交换 单向隧道 较多保护 时间短 两者都可以 I2P API]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>匿名网络</tag>
        <tag>流量识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登山赛车破解]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%99%BB%E5%B1%B1%E8%B5%9B%E8%BD%A6%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文主要记录破解登山赛车游戏的思路。 下载好apk ,放入模拟器中试玩一下，我们点击购买金币，不支付的话会提示购买失败。 我们可以看到付款失败特别明显，我们可以把apk拖进android killer里面搜索一下付款 失败的字符，找到提示付款失败的代码。 可以看到是一个switch语句，我们找到添加金币的代码。 这里是付款失败的代码块 下面两端代码块是添加的金币的代码块。 我们尝试把它拖到最下面，可以看到这样的代码。 我们将两个都改为:pswitch_0。 编译完成，再拖入模拟器里面试一下 成功获取金币，破解成功。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解糖果星星达人]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%A0%B4%E8%A7%A3%E7%B3%96%E6%9E%9C%E6%98%9F%E6%98%9F%E8%BE%BE%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[本文主要记录破解糖果星星达人游戏思路。 试玩一下糖果星星达人，尝试一下破解金币。把apk 扔到模拟器里面玩一下，还是蛮好玩的，反正死了就要让你充值金币，我们任意输入他提示购买失败，我们尝试一下破解。试着将apk扔进Android Killer里面，搜过一下关键字“购买失败” 很简单，就是个switch语句，上下浏览一下，找到购买成功 我们还看到了购买取消，我们拖到最下面，尝试把5、6改成4，看能否成功 重新编译，放入模拟器中，购买成功。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
</search>
